#!/usr/bin/env node
/**
 * Gemini Issue Analyzer
 *
 * GitHub Issue를 분석하고:
 * 1. 명세 업데이트 제안 (OpenAPI, DB Schema, Policy)
 * 2. 작업 분해 및 LLM 할당
 * 3. 초기 코드 스켈레톤 생성
 * 4. Claude Inbox 프롬프트 생성
 *
 * Environment Variables:
 * - GEMINI_API_KEY: Google AI Studio API key (required)
 * - ISSUE_NUMBER: GitHub issue number
 * - ISSUE_TITLE: Issue title
 * - ISSUE_BODY: Issue description
 */

import { writeFile, mkdir } from 'fs/promises';

// Use Gemini 1.5 Flash via v1 API (stable)
// v1 API is more stable than v1beta
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent';

/**
 * Gemini API 호출
 */
async function callGemini(prompt) {
  const apiKey = process.env.GEMINI_API_KEY;

  if (!apiKey) {
    throw new Error('GEMINI_API_KEY environment variable is required');
  }

  const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [{
        parts: [{ text: prompt }]
      }],
      generationConfig: {
        temperature: 0.2,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 8192,
      },
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Gemini API error: ${response.status} ${error}`);
  }

  const data = await response.json();
  return data.candidates[0].content.parts[0].text;
}

/**
 * Issue 분석 및 명세 생성
 */
async function analyzeIssue() {
  const issueNumber = process.env.ISSUE_NUMBER || 'unknown';
  const issueTitle = process.env.ISSUE_TITLE || 'Unknown Issue';
  const issueBody = process.env.ISSUE_BODY || '';

  console.log(`Analyzing Issue #${issueNumber}: ${issueTitle}`);

  const prompt = `You are a Spec-First development assistant.

Analyze this GitHub Issue and generate:
1. OpenAPI specification updates
2. Database schema changes
3. Policy updates
4. Task breakdown with LLM assignments

Issue #${issueNumber}: ${issueTitle}

Description:
${issueBody}

Please provide:

## 1. Specification Updates

### OpenAPI (YAML):
\`\`\`yaml
# paths to add/modify
\`\`\`

### Database Schema (SQL):
\`\`\`sql
-- migrations to create
\`\`\`

### Policy Updates (Markdown):
\`\`\`markdown
# specs/policy.md additions
\`\`\`

## 2. Task Breakdown

Estimated Time: X hours

### [Claude Code] Task 1 (Xh)
- Subtask 1
- Subtask 2

### [Codex] Task 2 (Xh) - PARALLEL
- Subtask 1
- Subtask 2

## 3. Initial Code Structure

### Backend Files:
\`\`\`typescript
// src/...
\`\`\`

### Frontend Files:
\`\`\`typescript
// src/components/...
\`\`\`

## 4. Success Criteria
- [ ] Criterion 1
- [ ] Criterion 2

Format the response as structured Markdown.`;

  const analysis = await callGemini(prompt);

  console.log('Gemini analysis completed');

  // 분석 결과 파싱 및 파일 생성
  await generateSpecFiles(analysis, issueNumber);
  await generatePrompts(analysis, issueNumber);
  await generatePRBody(analysis, issueNumber, issueTitle);

  console.log('✅ All files generated successfully');
}

/**
 * 명세 파일 생성
 */
async function generateSpecFiles(analysis, issueNumber) {
  // spec-updates 디렉토리 생성
  await mkdir('spec-updates', { recursive: true });

  // OpenAPI 추출
  const openapiMatch = analysis.match(/```yaml\n([\s\S]*?)\n```/);
  if (openapiMatch) {
    await writeFile('spec-updates/openapi.yaml', openapiMatch[1]);
    console.log('Generated: spec-updates/openapi.yaml');
  }

  // SQL 추출
  const sqlMatch = analysis.match(/```sql\n([\s\S]*?)\n```/);
  if (sqlMatch) {
    await writeFile('spec-updates/migration.sql', sqlMatch[1]);
    console.log('Generated: spec-updates/migration.sql');
  }

  // Policy 추출
  const policyMatch = analysis.match(/### Policy Updates[\s\S]*?```markdown\n([\s\S]*?)\n```/);
  if (policyMatch) {
    await writeFile('spec-updates/policy.md', policyMatch[1]);
    console.log('Generated: spec-updates/policy.md');
  }
}

/**
 * 프롬프트 생성
 */
async function generatePrompts(analysis, issueNumber) {
  // TODO: Task Breakdown에서 프롬프트 추출 및 생성
  // prompts/P{number}-{llm}-{description}.md 형식으로 생성

  console.log('Prompts would be generated here');
}

/**
 * PR Body 생성
 */
async function generatePRBody(analysis, issueNumber, issueTitle) {
  const prBody = `# Specification Update for Issue #${issueNumber}

## Issue
${issueTitle}

## Gemini Analysis

${analysis}

## Changes
- OpenAPI spec updated
- Database schema designed
- Policy additions

## Next Steps
1. Review and approve this PR
2. LLMs will implement based on these specifications
3. Automated testing will verify implementation

---

*Generated by Gemini Spec Manager*
`;

  await writeFile('spec-pr-body.md', prBody);
  console.log('Generated: spec-pr-body.md');
}

/**
 * Main
 */
async function main() {
  try {
    await analyzeIssue();
    process.exit(0);
  } catch (error) {
    console.error('❌ Analysis failed:', error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

main();
