#!/usr/bin/env node
/**
 * Spec↔OpenAPI↔DDL Drift Check (payments focus)
 * EN canonical. Heuristic but actionable; emits markdown report and non‑zero exit on drift.
 *
 * What it verifies (minimum viable):
 * 1) OpenAPI has required endpoints/headers/schemas for payments flows
 * 2) DDL contains required tables/columns/indexes for idempotency + webhook dedup + orders mapping
 * 3) Enumerations/field names align across contracts (eventType/status sets)
 *
 * Inputs (defaults):
 *   --openapi openapi/api-spec.yaml
 *   --ddl db/schema.pg.sql
 *   --mig migrations/20251025_0001_payments.sql (optional, augments checks)
 * Outputs:
 *   reports/spec-openapi-ddl-drift.md
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import YAML from 'yaml';

const ROOT = process.cwd();
const args = Object.fromEntries(process.argv.slice(2).reduce((a, x, i, arr) => (x.startsWith('--') ? (a.push([x.replace(/^--/, ''), arr[i + 1]]), a) : a), []));

const OPENAPI_PATH = path.join(ROOT, args.openapi || 'openapi/api-spec.yaml');
const DDL_PATH = path.join(ROOT, args.ddl || 'db/schema.pg.sql');
const MIG_PATH = path.join(ROOT, args.mig || 'migrations/20251025_0001_payments.sql');
const REPORT_DIR = path.join(ROOT, 'reports');
const REPORT_PATH = path.join(REPORT_DIR, 'spec-openapi-ddl-drift.md');

const EXPECT = {
  endpoints: ['/orders/prepare#post', '/webhooks/payments#post'],
  headers: ['Idempotency-Key', 'X-Payment-Provider', 'X-Provider', 'x-signature', 'x-signature-timestamp'],
  schemas: {
    PrepareOrderResponse: {
      fields: ['orderId', 'status', 'provider'],
      statusEnum: ['PENDING', 'COMPLETED', 'FAILED', 'REFUNDED', 'REQUIRES_ACTION']
    },
    WebhookGeneric: {
      fields: ['eventType', 'provider', 'providerEventId', 'providerPaymentId', 'occurredAt'],
      eventEnum: ['payment.succeeded', 'payment.failed', 'payment.refunded', 'requires_action', 'ping']
    }
  },
  ddl: {
    tables: {
      idempotency_keys: ['idem_key', 'scope', 'response_hash', 'status_code', 'locked_at', 'completed_at', 'expires_at'],
      payment_webhook_events: ['provider', 'provider_event_id', 'provider_payment_id', 'event_type', 'signature_ok', 'payload_hash', 'received_at'],
      orders: ['provider', 'provider_payment_id', 'provider_meta']
    },
    unique: [
      { on: 'payment_webhook_events', hint: '(provider, provider_event_id)' },
      { on: 'orders', hint: '(provider, provider_payment_id)' }
    ],
    enumTypes: ['payment_webhook_processing_status']
  }
};

const report = { ok: [], warn: [], fail: [] };

function ok(msg){ report.ok.push(`✔ ${msg}`); }
function warn(msg){ report.warn.push(`⚠ ${msg}`); }
function fail(msg){ report.fail.push(`✖ ${msg}`); }

async function fileOrNull(p){ try { return await fs.readFile(p, 'utf8'); } catch { return null; } }

function loadOpenAPI(raw){ try { return YAML.parse(raw); } catch { return null; } }

function hasPathVerb(spec, pathKey, verb){ return Boolean(spec?.paths?.[pathKey]?.[verb]); }

function headerRefsInOp(op){
  const params = op?.parameters || [];
  const names = new Set();
  for (const p of params){ if (p?.name) names.add(p.name); if (p?.$ref) names.add(refName(p.$ref)); }
  return names;
}

function refName($ref){ return String($ref).split('/').pop(); }

function collectHeaders(spec){
  const set = new Set(Object.values(spec?.components?.parameters || {}).map(p => p?.name).filter(Boolean));
  return set;
}

function collectSchemas(spec){ return spec?.components?.schemas || {}; }

// Very light SQL parser for our needs
function parseTables(sql){
  const tables = {};
  const reTable = /CREATE\s+TABLE\s+IF\s+NOT\s+EXISTS\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^;]+?)\);/gims;
  let m; while ((m = reTable.exec(sql))){
    const name = m[1];
    const cols = new Set();
    const body = m[2];
    for (const line of body.split(/,\n|,\r?\n|,/)){
      const cm = line.match(/\b([a-zA-Z_][a-zA-Z0-9_]*)\b\s+[A-Z]/);
      if (cm) cols.add(cm[1]);
    }
    tables[name] = cols;
  }
  return tables;
}

function hasUnique(sql, table, hint){
  const re = new RegExp(`CREATE\\s+UNIQUE\\s+INDEX[\\s\\S]+ON\\s+${table}\\s*\\${hint.replace(/[()]/g, m=>`\\${m}`)}`, 'i');
  return re.test(sql);
}

function findEnumTypes(sql){
  const set = new Set();
  const re = /CREATE\s+TYPE\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+AS\s+ENUM/gi;
  let m; while ((m = re.exec(sql))) set.add(m[1]);
  return set;
}

function md(){
  const lines = [
    '# Spec↔OpenAPI↔DDL Drift Report (payments focus)',
    '',
    '## Summary',
    `- ✅ OK: ${report.ok.length}`,
    `- ⚠ WARN: ${report.warn.length}`,
    `- ❌ FAIL: ${report.fail.length}`,
    '',
    '## Details',
    ...report.ok,
    ...report.warn,
    ...report.fail,
    '',
    '---',
    '_Generated by scripts/spec-drift-check.mjs_'
  ];
  return lines.join('\n');
}

async function main(){
  const [oaRaw, ddlRaw, migRaw] = await Promise.all([fileOrNull(OPENAPI_PATH), fileOrNull(DDL_PATH), fileOrNull(MIG_PATH)]);

  if (!oaRaw){ fail(`OpenAPI not found at ${OPENAPI_PATH}`); }
  if (!ddlRaw){ fail(`DDL not found at ${DDL_PATH}`); }

  const spec = oaRaw ? loadOpenAPI(oaRaw) : null;
  const ddl = ddlRaw || '';
  const mig = migRaw || '';
  const ddlAll = ddl + '\n' + mig; // include migration when present

  // 1) OpenAPI checks
  if (spec){
    for (const ep of EXPECT.endpoints){
      const [pth, verb] = ep.split('#');
      if (hasPathVerb(spec, pth, verb)) ok(`OpenAPI endpoint present: ${ep}`); else fail(`OpenAPI endpoint missing: ${ep}`);
    }

    // headers (in components and operations)
    const headerPool = collectHeaders(spec);
    for (const h of EXPECT.headers){
      if (headerPool.has(h)) ok(`Header parameter declared: ${h}`); else warn(`Header parameter not declared in components.parameters: ${h}`);
    }

    const schemas = collectSchemas(spec);
    // PrepareOrderResponse
    const prep = schemas['PrepareOrderResponse'];
    if (!prep) fail('Schema missing: PrepareOrderResponse');
    else {
      const props = Object.keys(prep?.properties || {});
      for (const f of EXPECT.schemas.PrepareOrderResponse.fields){
        if (props.includes(f)) ok(`PrepareOrderResponse has field: ${f}`); else fail(`PrepareOrderResponse missing field: ${f}`);
      }
      const enumVals = prep?.properties?.status?.enum || [];
      for (const ev of EXPECT.schemas.PrepareOrderResponse.statusEnum){
        if (enumVals.includes(ev)) ok(`status enum contains: ${ev}`); else fail(`status enum missing: ${ev}`);
      }
    }

    // WebhookGeneric
    const wh = schemas['WebhookGeneric'];
    if (!wh) fail('Schema missing: WebhookGeneric');
    else {
      const props = Object.keys(wh?.properties || {});
      for (const f of EXPECT.schemas.WebhookGeneric.fields){
        if (props.includes(f)) ok(`WebhookGeneric has field: ${f}`); else fail(`WebhookGeneric missing field: ${f}`);
      }
      const enumVals = wh?.properties?.eventType?.enum || [];
      for (const ev of EXPECT.schemas.WebhookGeneric.eventEnum){
        if (enumVals.includes(ev)) ok(`eventType enum contains: ${ev}`); else fail(`eventType enum missing: ${ev}`);
      }
    }
  }

  // 2) DDL checks
  if (ddlAll){
    const tables = parseTables(ddlAll);
    for (const [t, fields] of Object.entries(EXPECT.ddl.tables)){
      if (!tables[t]) { fail(`Table missing: ${t}`); continue; }
      ok(`Table present: ${t}`);
      for (const col of fields){
        if (tables[t].has(col)) ok(`${t}.${col} present`); else fail(`${t}.${col} missing`);
      }
    }
    for (const ix of EXPECT.ddl.unique){
      if (hasUnique(ddlAll, ix.on, ix.hint)) ok(`UNIQUE index present on ${ix.on} ${ix.hint}`); else fail(`UNIQUE index missing on ${ix.on} ${ix.hint}`);
    }
    const enums = findEnumTypes(ddlAll);
    for (const et of EXPECT.ddl.enumTypes){
      if (enums.has(et)) ok(`ENUM type present: ${et}`); else warn(`ENUM type not found (may be created elsewhere): ${et}`);
    }
  }

  // 3) Cross checks (names only)
  // Ensure OpenAPI WebhookGeneric.providerPaymentId aligns with orders.provider_payment_id existence
  const hasOrders = /CREATE\s+TABLE[\s\S]+orders[\s\S]+\(/i.test(ddlAll);
  const hasProvPayCol = /orders[\s\S]+ADD\s+COLUMN[\s\S]+provider_payment_id|\bprovider_payment_id\b/i.test(ddlAll);
  if (hasOrders && hasProvPayCol) ok('orders.provider_payment_id exists to reconcile webhook → order');
  else warn('orders.provider_payment_id not detected; webhook reconciliation may fail');

  // Write report
  await fs.mkdir(REPORT_DIR, { recursive: true });
  await fs.writeFile(REPORT_PATH, md());

  // Exit code
  const failed = report.fail.length > 0;
  console.log(`Drift check done. Report: ${path.relative(ROOT, REPORT_PATH)}`);
  if (failed) {
    console.error(`❌ Drift detected: ${report.fail.length} failures, ${report.warn.length} warnings.`);
    process.exit(2);
  } else {
    console.log(`✅ No blocking drift. Warnings: ${report.warn.length}.`);
  }
}

main().catch((e) => { console.error('Drift check error:', e?.message || e); process.exit(1); });
